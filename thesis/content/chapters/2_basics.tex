\chapter{Grundlagen}

\section{Digitale Signaturen}
Digitale Signaturen sind vergleichbar mit einer handschriftlichen Unterschrift in digitaler Form. Die Signatur soll die Authentizität eines Datenobjekts beweisen, indem sie den genauen Inhalt unumstößlich mit einer Autorität verknüpft. Diese Autorität ist meist der Autor des Datenobjekts oder eine Instanz, die sich für den Inhalt verbürgt. Dabei muss sichergestellt sein, dass die Signatur nur mit einem geheimen Schlüssel, dem Private Key, erstellt werden kann. Dessen Inhalt darf nur dem Ersteller der Signatur bekannt sein. Die Signatur muss mit einem öffentlichen Schlüssel von jedem verifiziert werden können, dem Public Key. Das Ergebnis der Verifikation muss wiederum eindeutig dem Ersteller der Signatur zuzuordnen sein. Digitale Signaturen gehören somit zu den asymmetrischen kryptographischen Verfahren.\cite[S.29]{1841202}\cite[S.425f.]{548089}\\
Digitale Signaturen sind ein weit verbreitetes Verfahren in der Informationssicherheit und werden z.B. zur Authentifizierung, Daten-Integrität oder Nachweisbarkeit (Non-Repudiation) eingesetzt.\\
Grundlegende Definition\cite[S.426f.]{548089}:
\begin{enumerate}
\item Eine 'digitale Signatur' ist eine Datenfolge, welche ein digitales Datenobjekt mit einer Autorität assoziiert.
\item Ein 'Generierungsalgorithmus' erzeugt eine digitale Signatur.
\item Ein 'Verifikationsalgorithmus' für digitale Signaturen verifiziert die Authentizität der Signatur.
\item Ein 'Signaturschema' besteht aus einem Generierungsalgorithmus und den Verifikationsalgorithmen.
\item Ein 'digitaler Signierungsprozess' besteht aus einem Algorithmus zum Erstellen der Signatur und einer Konvertierung, welche Daten in ein signierbares Format überführt.
\item Der 'Verifikationsprozess' einer digitalen Signatur besteht aus einem Algorithmus zum Verifizieren einer Signatur und einer Konvertierung, welche Daten in ein verifizierbares Format überführt.\\
\end{enumerate}


\subsection{RSA}
\acs{RSA}, benannt nach den Entwicklern Ron Rivest, Adi Shamir und Leonard Adleman, ist das am weitesten verbreitete assymetrische Kryptosystem in der Informatik. \acs{RSA}  verwendet ein Schlüsselpaar, bestehend aus einem privaten Schlüssel, der zum Entschlüsseln oder Signieren verwendet wird, und einem öffentlichen Schlüssel, mit dem man Daten vertschlüsselt oder Signaturen prüft. Der private Schlüssel wird geheim gehalten und kann nicht aus dem öffentlichen Schlüssel berechnet werden. \acs{RSA} kann sowohl zum digitalen Signieren, als auch zum Verschlüsseln von Daten verwendet werden und benutzt eine sogenannte Einwegfunktion für die Verschlüsselung. Einwegfunktionen sind Funktionen, bei denen der Hinweg einfach zu berechnen ist, aber die Umkehrfunktion nur sehr schwer. \acs{RSA} nutzt dabei das mathematische Problem, dass es schwierig ist, die Faktorisierung großer Zahlen zu berechnen. Die Umkehrung ist jedoch trivial, da man beliebige, große Primzahlen multiplizieren kann, um eine große Zahl und ihre Faktorisierung zu erhalten. Um \acs{RSA} auch als Verschlüsselung benutzen zu können, muss die Einwegfunktion unter zuhilfenahme des Private Keys einfach zu berechnen sein. Mit dem öffentlichen Public Key kann eine mit dem Private Key erstellte Signatur validiert werden. Das \acs{RSA} Verfahren kann auch genutzt werden, um Daten mittels Public Key zu verschlüsseln. Diese können dann nur durch den zugehörigen Private Key wieder entschlüsselt werden. \cite[S.195, 200ff.]{1841202} \cite[S.433ff.]{548089}

\section{Hashfunktionen}
Eine Hashfunktion, im deutschen auch als Streuwertfunktion bezeichnet, ermöglicht es Daten beliebiger Größe auf Daten fester Größe abzubilden. Da diese Abbildungsfunktion typischerweise von einer größeren Wertemenge auf eine kleinere abbildet, kann es zu Kollisionen kommen. Daraus ergibt sich die Eigenschaft der Kollisionswahrscheinlichkeit der Hashfunktion. Eine gute Hashfunktion bildet möglichst selten unterschiedliche Eingabewerte auf denselben Hashwert ab. Hashfunktionen können auch speziell auf einen Typ von Eingangsdaten angepasst werden, um Kollisionen zu minimieren oder gar auszuschließen. Jedoch können allgemeine Hashfunktionen nie komplette Kollisionsfreiheit garantieren. Anwendungsbereiche für Hashfunktionen sind z.B. Schlüsselgenerierung von Hashtabellen, Passwortvalidierung, Prüfsummen und andere kryptographische Verifikationsverfahren.
Erstrebenswerte Eigenschaften von Hashfunktionen sind:
\begin{itemize}
\item Der komplette Abbildungsbereich soll unabhängig von der Eingabe gleichmäßig genutzt werden, um Kollisionen zu minimieren.
\item Ein minimal anderer Eingabewert eine genau so große Änderung am Ausgabewert bewirkt, wie jeder andere Eingabewert, dies wir als 'Chaos-' oder  'Lawineneffekt' bezeichnet.
\item Vom Ausgabewert sollen keine Rückschlüsse auf die Eingabe gemacht werden können. Weitergehend soll es auch keine Möglichkeit geben aus dem Ergebnis wieder den Ursprungswert zu berechnen.
\item Die Hashfunktion soll möglichst schnell berechenbar sein.
\end{itemize}
\cite[S.77ff.]{1841202}

\section{SHA-2}
\acs{SHA}-2 (Secure Hash Algorithm) ist eine Gruppe von Hashfunktion, die erstmals 2001 vom National Institute of Standards and Technology (NIST) standardisiert wurde. \acs{SHA}-2 ersetzt seinen Vorgänger \acs{SHA}-1 komplett, da dessen Sicherheit mittels einer Sicherheitslücke nicht mehr gewährleistet werden konnte. Mit \acs{SHA}-3 gibt es bereits seit 2015 einen Nachfolger zu \acs{SHA}-2. \acs{SHA}-3 verwendet ein Verfahren, das theoretische Schwächen von \acs{SHA}-2 eliminiert. Das neue Verfahren ist dadurch aber rechenintensiver. Da \acs{SHA}-2 bisher nicht gebrochen wurde, gibt es bisher keinen zwingenden Grund den neueren Algorithmus einzusetzen.
Die \acs{SHA}-2 Gruppe beinhaltet verschiedene Funktionen wie z.B. \acs{SHA}-256, \acs{SHA}-512, \acs{SHA}-512/256, \ldots Die Nummern am Ende stehen dabei für die verwendete Anzahl von Bits  und sind z.T. intern und extern verschieden. Bei einer Diskrepanz zwischen interner State-Größe in Bits und des zurückgegebenen Ergebnisses des Algorithmus wird im Namen erst die interne Anzahl an Bits, dann die Anzahl an Bits der Ausgabe angegeben. Die verschiedenen Funktionen wurden nach und nach in den Standard aufgenommen. Der neueste \acs{SHA}-2 Algorithmus wurde 2012 hinzugefügt.
Die vom NIST standardisierten Hashverfahren sind allgemein vertrauenswürdig und weit verbreitet. In Java und anderen Sprachen sind die \acs{SHA}-2 Algorithmen Teil der Standardbibliothek. \cite[S.82f]{1841202}

\section{Hashchains}
Eine Hashchain ist eine kryptographische Struktur, bei der aufeinanderfolgende Daten immer wieder mit in eine Hashfunktion verrechnet werden. Das Ergebnis der Hashfunktion ist der Element-Hash. Er wird in der Berechnung für das folgende Element mit einbezogen. So entsteht eine Kette von Hashwerten die rekursiv, aus dem jeweiligen Vorgänger Element-Hash und den Daten des zu verkettenden Elements berechnet werden. Der Element-Hash am Ende der Kette enthält somit die Verifikation über alle Elemente der Hashchain. Zur Verifikation kann die Berechnung ab einem beliebigen Punkt der Kette wiederholt werden. Wenn die erneut berechneten Hashwerte identisch zu den Originalen sind, ist garantiert, dass die verketteten Daten unverändert sind. Die Korrektheit dieser Verifikation basiert auf der Kollisionsresistenz der benutzten Hashfunktion.\cite[S.351ff]{40322788}

\section{Hashlists}
Hashlists ähneln Hashchains, jedoch sind die Elemente einer Hashlist unabhängig. Jedes Element einer Hashlist wird über eine Hashfunktion einem Hashwert zugewiesen. Die so generierten Einzel-Hashes werden wiederum zu einem Top-Hash zusammengefasst. Dieser Top-Hash verifiziert, wie schon bei der Hashchain, alle Daten in der Liste. Eine Verifikation ist aber durch Neuberechnung dieses Top-Hashes möglich. Es werden immer alle Hashwerte der Liste benötigt. Eine partielle Verifikation wie bei der Hashchain ist hier nicht möglich.\cite[S.18f]{326652}

\section{Merkle tree}
Der Merkle tree ist nach dem Erfinder Ralph Merkle benannt. Er wird auch als binärer Hashbaum bezeichnet. Merkle trees werden zum Zusammenfassen und der effizienten Integritätsüberprüfung großer Datensätzen verwendet. Bei Merkle trees werden die zu speichernden Daten und deren errechneter Hashwert in den Blättern abgelegt. Diese werden dann binärbaumtypisch in Paaren zu einem Elternknoten zusammengeführt. Der Elternknoten und alle weiteren Knoten bis zur Wurzel bilden ebenfalls einen Hashwert. Zur Berechnung dieser Hashes werden die bereits bekannten Hashwerte der Kind-Knoten zusammengefasst und erneut in die Hashfunktion eingegeben. Somit hält jeder Knoten mit seinem Hashwert eine prüfbare Verifikation der Integrität aller Knoten unter ihm. Im Falle eines Knotens mit nur einem Kind wird zur Berechnung des Eltern-Knotens der vorhandene Hash mit sich selbst konkateniert und wie gehabt verarbeitet. Dank der Baumstruktur kann in einem Merkle tree mit $N$ Elementen die Existenz eines gegebenen Elements mit einem Aufwand von $2 * log\textsubscript{2}(N)$ nachgewiesen werden, was ihn zu einer effizienten Datenstruktur macht.

\section{Blockchain}
Blockchain ist ein dezentrales System zum Speichern verifizierter Transaktionen. Einzelne Instanzen im Blockchain-Netzwerk werden als Nodes bezeichnet, diese arbeiten unabhängig und kontrollieren sich gegenseitig. Jeder Node hat die Möglichkeit neue Blöcke zu bilden oder Informationen aus den vorhandenen Daten abzurufen.\cite[S.197ff]{5841204}
\subsection{Blockchain-Datenstruktur}
Die Blockchain-Datenstruktur verbindet die oben genannten Verfahren und definiert ein Verfahrensprotokoll, um die Struktur zu verwalten. Die grundlegende Struktur einer Blockchain basiert auf einer normalen Hashchain. Jeder Block in der Kette verweist auf seinen Vorgänger. Zur Berechnung des Hashes eines neuen Blocks werden im Header Informationen aus dem Vorgänger mit einbezogen. Der Header besteht üb­li­cher­wei­se aus dem Hash des Vorgängers, dem Wurzel-Hash der Transaktions-Datenstruktur und Metainformationen für das Protokoll. Um die Transaktionsinformationen innerhalb eines Blocks abzubilden werden Merkle trees verwendet. \cite[S.197ff]{5841204}
\subsection{Blockchain-Forks}
Da Bockchain ein dezentrales System ist, kann es vorkommen, dass es temporär mehrere Kinder zu einem Block gibt. Das Hinzufügen eines neuen Blocks wird immer allen Teilnehmern des Systems mitgeteilt. Wenn jedoch zwei neue Blöcke zeitgleich entstehen, nennt man dieses Ereignis einen Blockchain-Fork. Dieser löst sich erst auf, wenn weitere Blöcke gefunden wurden. Teilnehmer der Blockchain arbeiteten immer an der Kette von Blöcken weiter, die am meisten Blöcke vom Ursprungsknoten entfernt ist. Wenn es nun konkurrierende Ketten gibt wird die Kette, die sich zuerst weiter vom Ursprungsknoten entfernt, durchsetzen. Im Falle eines so invalidierten Forks müssen alle dort eingetragenen Transaktionen auf einen Block in der aktuell gültigen Kette transferiert werden.\cite[S.199, 241ff]{5841204}
\subsection{Blockchain-Sicherheit}
Die Sicherheit einer Blockchain basiert auf der Abhängigkeit der Blöcke voneinander. Je älter ein Block in einer Blockchain ist, desto sicherer wird er. Zum Ändern eines Blocks ist eine komplette Neuberechnung aller Blöcke ab diesem Punkt nötig. Um einen Block anfügen zu dürfen, ist ein Konsensverfahren notwendig. Als solches wird beispielsweise eine "`Proof-Of-Work-Methode"' verwendet, welche Arbeit in der Form von Rechenleistung benötigt, um einen neuen Block zu "`finden"'. Der neue Block wurde unter Einsatz von viel Rechenleistung gesucht, die Validierung eines gefundenen Blocks ist wiederum einfach. Es kann aber auch eine beliebige andere Methode verwendet werden, um einen gemeinsamen Konsens zu erlangen. Wenn der Konsens gefunden wurde kann die Kette erweitert werden. Die Generierung eines Konsens soll dabei für eine einzelne Instanz schwierig sein um die Kontrolle zu dezentralisieren und Manipulationen zu vermeiden.\cite[S.219]{5841204}
